[{"/home/marcus/othello/src/index.tsx":"1","/home/marcus/othello/src/reportWebVitals.ts":"2","/home/marcus/othello/src/App.tsx":"3","/home/marcus/othello/src/Const.tsx":"4"},{"size":500,"mtime":1609426819553,"results":"5","hashOfConfig":"6"},{"size":425,"mtime":1609426819566,"results":"7","hashOfConfig":"6"},{"size":7689,"mtime":1609496017629,"results":"8","hashOfConfig":"6"},{"size":6701,"mtime":1609444152674,"results":"9","hashOfConfig":"6"},{"filePath":"10","messages":"11","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"12"},"mpsl8b",{"filePath":"13","messages":"14","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"12"},{"filePath":"15","messages":"16","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"17","usedDeprecatedRules":"12"},{"filePath":"18","messages":"19","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"20"},"/home/marcus/othello/src/index.tsx",[],["21","22"],"/home/marcus/othello/src/reportWebVitals.ts",[],"/home/marcus/othello/src/App.tsx",["23"],"import _ from 'lodash';\nimport './App.css';\nimport { tiles, initial } from './Const';\nimport React from 'react';\nimport { useState, useEffect } from 'react';\nimport { compact } from 'fp-ts/lib/Array';\nimport { pipe } from 'fp-ts/function';\nimport * as O from 'fp-ts/Option';\n\nconst AI = 1;\n\nconst COLORS = {\"1\": \"is-black\", \"-1\": \"is-white\"};\n\nconst MOVES = _.range(tiles.length);\n\nclass Data {\n    board: Array<number>;\n    side: number = 0;\n\n    constructor(board: Array<number>, side: number) {\n        this.board = board;\n        this.side = side;\n\n        this.count = this.count.bind(this);\n        this.filterFlips = this.filterFlips.bind(this);\n        this.canPlayMove = this.canPlayMove.bind(this);\n        this.canPlay = this.canPlay.bind(this);\n        this.fromMove = this.fromMove.bind(this);\n    }\n\n    count(side: number) {\n        return this.board.filter(e => e === side).length;\n    }\n\n    winner() {\n        return this.count(1) >= this.count(-1) ? 1 : -1;\n    }\n\n    filterFlips(l: Array<number>) {\n        const s = _.takeWhile(l, i => this.board[i] === -this.side);\n        return this.board[l[s.length]] ? s : [];\n    }\n\n    canPlayMove(i: number)  {\n        return !this.board[i] && tiles[i].some(l => this.filterFlips(l).length > 0);\n    }\n\n    canPlay() {\n        return MOVES.some(this.canPlayMove);\n    }\n\n    fromMove(move: number): O.Option<Data> {\n        if (this.board[move]) return O.none;\n        let board = _.cloneDeep(this.board);\n        const ls = tiles[move].map(this.filterFlips).filter(l => l.length);\n        if (!ls.length) return O.none;\n        for (const l of ls) {\n            board[move] = this.side;\n            for (const i of l) {\n                if (!board[i]) break;\n                board[i] = this.side;\n            }\n        }\n        for (const side of [-this.side, this.side]) {\n            const _data = new Data(board, side);\n            if (_data.canPlay()) return O.some(_data);\n        }\n        return O.some(new Data(board, 0));\n    }\n\n    allStates = (): Array<Data> => compact(MOVES.map(this.fromMove));\n}\n\nclass UCTNode {\n    chinfo: O.Option<[Array<UCTNode>, number]> = O.none;\n    parent: O.Option<UCTNode> = O.none; \n    _data: Data;\n    visits = 0;\n    wins = 0;\n\n    constructor(data: Data, parent: O.Option<UCTNode>) {\n        this._data = _.cloneDeep(data);\n        this.parent = parent;\n\n        this.value = this.value.bind(this);\n        this.selexp = this.selexp.bind(this);\n        this.rollout = this.rollout.bind(this);\n        this.update = this.update.bind(this);\n        this.backprog = this.backprog.bind(this);\n    }\n\n    best = () => pipe(\n        this.chinfo,\n        O.chain(([children, cnt]) =>\n            O.fromNullable(_.maxBy(children, c => {\n                if (!c.visits) return 0;\n                const avg = c.wins / c.visits;\n                return !c._data.side ? c._data.winner() === AI\n                    : (c._data.side === AI ? avg : 1 - avg);\n            }))\n        )\n    );\n            \n    value() {\n        if (!this.visits) return Infinity;\n        const N = pipe(\n            this.parent,\n            O.map(node => node.visits),\n            O.getOrElse(() => 1)\n        );\n        return this.wins / this.visits\n            + Math.sqrt(2 * Math.log(N) / this.visits);\n    }\n\n    can_explore = () => this._data.side && pipe(\n        this.chinfo,\n        O.map(([children, cnt]) => cnt > 0),\n        O.getOrElse(() => true)\n    );\n\n    selexp = (): O.Option<UCTNode> => pipe(\n        this.chinfo,\n        O.chain(([children, cnt]) => {\n            const pos = children.filter(c => c.can_explore());\n            return pipe(\n                _.maxBy(pos, c => c.value()),\n                O.fromNullable,\n                O.chain(node => node.selexp()),\n            );\n        }), // guaranteed isNone\n        O.alt(() => {\n            const children = this._data.allStates()\n                .map(e => new UCTNode(e, O.some(this)));\n            const eligible = children.filter(e => e._data.side);\n            this.chinfo = O.some([children, eligible.length]);\n            return O.fromNullable(_.sample(eligible));\n        }), // null if no children\n        O.alt(() => pipe(\n            this.parent,\n            O.chain(node => {\n                node.update();\n                return node.selexp();\n            })\n        ))  // null at root\n    );\n\n    rollout() {\n        let sim = _.cloneDeep(this._data);\n        while (true) {\n            const t = _.sample(sim.allStates())\n                ?? new Data(sim.board, 0);\n            if (!t.side) return t.winner();\n            sim = t;\n        }\n    }\n\n    backprog(s: number) {\n        ++this.visits;\n        if (s === this._data.side) ++this.wins;\n        pipe(this.parent, O.map(node => node.backprog(s)));\n    }\n\n    update = () => {\n        const chinfo_ = O.toNullable(this.chinfo);\n        if (!chinfo_) return;\n        const [children, cnt] = chinfo_;\n        const cnt_ = cnt - 1;\n        this.chinfo = O.some([children, cnt_]);\n        if (!cnt_) {\n            const p = O.toNullable(this.parent);\n            p?.update();\n        }\n    }\n}\n\ninterface PropsHeader { children?: string; }\nfunction Header({ children = \"Copyright @ 2020 Marcus Xu\" }: PropsHeader) {\n    return (\n        <div className=\"header\">\n            <h1>Othello</h1>\n            <p>{ children }</p>\n        </div>\n    );\n}\n\ninterface PropsBoard { data: Data; handleClick: any; }\nfunction Board({ data, handleClick }: PropsBoard): any {\n    return data.board.map((e, i) => {\n        if (e) {\n            const className = `circle ${COLORS[e as 1|-1]}`;\n            return (\n                <div className=\"box\">\n                    <div className={className}></div>\n                </div>\n            );\n        } else if (data.canPlayMove(i)) {\n            const onClick = () => handleClick(i);\n            return (\n                <div className=\"box\">\n                    <div className=\"circle is-empty\" onClick={onClick}></div>\n                </div>\n            );\n        } else {\n            return <div className=\"box\"></div>;\n        }\n    });\n}\n\ninterface PropsCounter { data: Data; side: number; }\nfunction Counter({ data, side }: PropsCounter) {\n    const className = `counter ${COLORS[side as 1|-1]}`;\n    return (\n        <div className={className}>\n            <h1>{ data.count(side) }</h1>\n        </div>\n    );\n}\n\nconst App = () => {\n    const [data, setData] = useState(new Data(initial, 1));\n    const [stat, setStat] = useState({ wins: 0, visits: 0 });\n    const info = stat.visits\n        ? `Win rate: ${ Math.round(stat.wins / stat.visits * 100) }%` : undefined;\n    const handleClick = (e: number) => pipe(\n        data.fromMove(e), O.map(data => setData(data)));\n    const mcts = () => {\n        if (data.side !== AI) return O.none;\n        let root = new UCTNode(data, O.none);\n        const start = new Date();\n        while ((new Date()).getTime() - start.getTime() < 3000) {\n            for (let i = 0; i < 50; ++i) {\n                if (!root.can_explore()) return root.best();\n                const node = O.toNullable(root.selexp());\n                if (node) node.backprog(node.rollout());\n            }\n        }\n        setStat({ wins: root.wins, visits: root.visits });\n        return root.best();\n    }\n    useEffect(() => {\n        const bdata = O.toNullable(mcts())?._data;\n        if (bdata) setData(bdata);\n    }, [data]);\n    return (\n        <div className=\"container\">\n            <Header>{ info }</Header>\n            <Board data={data} handleClick={handleClick}/>\n            <Counter data={data} side={ 1}/>\n            <Counter data={data} side={-1}/>\n        </div>\n    );\n};\n\nexport default App;\n","/home/marcus/othello/src/Const.tsx",[],["24","25"],{"ruleId":"26","replacedBy":"27"},{"ruleId":"28","replacedBy":"29"},{"ruleId":"30","severity":1,"message":"31","line":243,"column":8,"nodeType":"32","endLine":243,"endColumn":14,"suggestions":"33"},{"ruleId":"26","replacedBy":"34"},{"ruleId":"28","replacedBy":"35"},"no-native-reassign",["36"],"no-negated-in-lhs",["37"],"react-hooks/exhaustive-deps","React Hook useEffect has a missing dependency: 'mcts'. Either include it or remove the dependency array.","ArrayExpression",["38"],["36"],["37"],"no-global-assign","no-unsafe-negation",{"desc":"39","fix":"40"},"Update the dependencies array to be: [data, mcts]",{"range":"41","text":"42"},[7398,7404],"[data, mcts]"]